; just delay!
(defn size-eq [args] (and (every? vector? args) (apply = (mapv size args))))
(defn num-vec? [v] (and (vector? v) (every? number? v)))
(defn vec-op [op] (fn [& vectors] (apply mapv op vectors)))
(def v+ (vec-op +))
(def v- (vec-op -))
(def v* (vec-op *))
(defn scalar [& vectors] (reduce + 0 (apply v* vectors)))
(defn vec-mul [v u] [(- (* (v 1) (u 2)) (* (v 2) (u 1)))
           (- (* (v 0) (u 2)) (* (v 2) (u 0)))
           (- (* (v 0) (u 1)) (* (v 1) (u 0)))])
(defn vect [& vectors] (reduce vec-mul vectors))
(defn v*s [v & scalars] (mapv (fn [a] (apply * a scalars)) v))

(defn num-mat? [m] (and (vector? m) (every? num-vec? m)))
(defn mat-op [op] (fn [& matrices] (apply mapv op matrices)))
(def m+ (mat-op v+))
(def m- (mat-op v-))
(def m* (mat-op v*))
(defn m*s [A & scalars] (mapv (fn [v] (apply v*s v scalars)) A))
(defn m*v [A v] (apply v+ (mapv v*s A v)))
(defn mat-mul [A B] (mapv (fn [v] (m*v A v)) B))
(defn m*m [& matrices] (reduce mat-mul matrices))
(defn transpose [A] (apply mapv vector A))

(defn shape-eq [args] (or (every? number? args) ()))
(defn tensor? [arg len-expected] (or (number? arg) (and  (size-eq))))
(defn ten-op [op-end-of-rec] (fn me [& comps]
                     (if (apply tensors? comps)
                       (apply mapv me comps)
                       (apply op-end-of-rec comps))
                               ))
(def t+ (ten-op +))

(println (vector? [0]))
(println (tensors? [0]))

;(println (scalar [60 80 90] [1 2 3] [100 100 0]))
;(def vectors [[60 80 90] [1 2 3] [100 100 0]])
;(println (apply v* [[60 80 90] [1 2 3] [100 100 0]]))
;(println (m- [[2 0] [-3 45] [900 -12]] [[54 2] [7 -0] [+0 34]] [[43 34] [1 -1] [29 8]]))
;(println (m*s [[2 0] [-3 45] [900 -12]] 1 2 -30))
;(println (m*v [[2 0] [-3 45] [900 -12] [21 0]] [2 -1 0 1]))
;(println (m*m [[1 0] [0 1]] [[13 -900] [0 1345]] [[1 0] [0 1]]))
;(println (transpose [[1 2] [3 4] [5 6] [7 8]]))